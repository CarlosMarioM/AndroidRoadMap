# Assisted Injection — Dagger & Hilt

This document explains **assisted injection** properly: what problem it solves, when it is mandatory, how to implement it correctly, and why most incorrect usages are architectural mistakes.

---

## What assisted injection actually is

Assisted injection is used when:
- Some dependencies are known **at compile time** (DI-provided)
- Some parameters are known **only at runtime** (user input, navigation args)

DI cannot create objects when **required constructor parameters are missing**.

Assisted injection solves exactly this — nothing more.

---

## When assisted injection is REQUIRED

You must use assisted injection when:
- A `ViewModel` needs navigation arguments
- An object needs an ID, token, or config only known at runtime
- You want multiple instances of the same class with different parameters

Example runtime-only data:
- `userId`
- `itemId`
- `FlowId`
- Feature flags fetched dynamically

If the value comes from UI or navigation → assisted injection.

---

## When assisted injection is NOT needed

Do NOT use assisted injection when:
- The value can come from a repository
- The value can be loaded asynchronously
- The value is static or global

Assisted injection is not a shortcut. It’s a constraint solver.

---

## Core concepts

Assisted injection has three mandatory pieces:
1. `@Assisted` parameters
2. An `@AssistedFactory`
3. Manual creation through the factory

Miss one → it does not work.

---

## Basic assisted injection example

### Step 1 — Define the class

```kotlin
class DetailViewModel @AssistedInject constructor(
    private val repository: ItemRepository,
    @Assisted private val itemId: String
) : ViewModel()
```

Only runtime parameters are annotated with `@Assisted`.

---

### Step 2 — Create the factory

```kotlin
@AssistedFactory
interface DetailViewModelFactory {
    fun create(itemId: String): DetailViewModel
}
```

This factory is generated by Dagger.

---

### Step 3 — Expose the factory

```kotlin
@Module
@InstallIn(ViewModelComponent::class)
interface DetailViewModelModule
```

Hilt automatically binds the factory.

---

### Step 4 — Use it manually

```kotlin
class DetailViewModelProvider(
    private val factory: DetailViewModelFactory
) {
    fun create(itemId: String): DetailViewModel =
        factory.create(itemId)
}
```

You now fully control creation.

---

## Assisted injection with Compose navigation

This is the **most common real-world case**.

```kotlin
@Composable
fun DetailScreen(
    itemId: String,
    factory: DetailViewModelFactory = hiltViewModel()
) {
    val viewModel = remember(itemId) {
        factory.create(itemId)
    }
}
```

Rules:
- Use `remember` to avoid recreation
- Assisted injection handles runtime args
- Hilt still injects dependencies

---

## Assisted injection vs SavedStateHandle

They solve **different problems**.

### SavedStateHandle
- Restores state after process death
- Comes from Android
- Is not DI

### Assisted injection
- Provides runtime parameters
- Compile-time safe
- DI-managed

They are often used together.

---

## Common mistakes (real-world bugs)

- Using assisted injection for async-loaded data
- Injecting navigation args into `@Singleton`
- Recreating assisted objects on recomposition
- Using assisted injection to bypass architecture

If assisted injection feels overused, the design is wrong.

---

## Compose-specific rules

- Recomposition does not affect assisted objects
- `remember` is mandatory when creating manually
- Never create assisted objects directly in Composables

Compose renders. DI creates.

---

## Rule of thumb

- Compile-time dependency → normal injection
- Runtime-only parameter → assisted injection
- UI recreation ≠ object recreation

If you hesitate, you probably don’t need assisted injection.

